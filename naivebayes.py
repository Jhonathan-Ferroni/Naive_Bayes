# -*- coding: utf-8 -*-
"""NaiveBayes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cic23tHzE10NJtfNaVbVAYyUWpOi3Y_F
"""

import pandas as pd
from sklearn.model_selection import train_test_split ##dividir os dados entre treino e teste
from sklearn.naive_bayes import GaussianNB
from sklearn.preprocessing import LabelEncoder ##codificação dos dados / dados categoricos --> informações numericos
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report
from yellowbrick.classifier import ConfusionMatrix ##gerar graficamente uma matriz de confusao

base = pd.read_csv('insurance.csv')
base

base = base.drop(columns=['Unnamed: 0'])
base

base.shape
base = base.where(pd.notna(base), 'None') #transforma nan em none

y = base.iloc[:,7].values   ##variavel dependente/classe, variavel que quero prever
X = base.iloc[:,[0,1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]].values ##variaveis independentes

y

labelencoder = LabelEncoder()

##percorrer as colunas para transformar atraves do labelencoder
for i in range(X.shape[1]):       ##criando um laço percorrer pelo numero de colunas se fosse pelas linhas seria [0]
  if X[:,i].dtype =='object':     ##se a variavel for categorica
    X[:,i] = labelencoder.fit_transform(X[:,i]) ##transformar em numero

X

##dividir dados em treino e teste
# X independetes
# y dependente
# 70%          #30%       #70%         #30%
X_treinamento, X_teste, y_treinamento, y_teste = train_test_split(X,y,test_size=0.3, random_state=1) ##70% sera treino, e repetir as amostras

modelo = GaussianNB()
modelo.fit(X_treinamento, y_treinamento)  ##treinando o modelo

previsoes = modelo.predict(X_teste)

previsoes

##medir performance

accuracy = accuracy_score(y_teste, previsoes)   #em teoria previsoes deveria ser o y de x_teste
precision = precision_score(y_teste, previsoes, average = 'weighted')
recall = recall_score(y_teste, previsoes, average = 'weighted')
f1 = f1_score(y_teste, previsoes, average ='weighted')
print(f'Acuracia: {accuracy}')
print(f'Precisao: {precision}')
print(f'Recall: {recall}')
print(f'F1: {f1}')

report = classification_report(y_teste, previsoes)
print(report)

confusao = ConfusionMatrix(modelo, classes=['None', 'Severe', 'Wild', 'Moderate'])
confusao.fit(X_treinamento, y_treinamento)
confusao.score(X_teste, y_teste)
confusao.poof()
